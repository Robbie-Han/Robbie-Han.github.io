---
title: url从输入到页面显示的过程
tags: 
- 网络
- DNS
- 三次握手
- 四次挥手
toc: true
---
## 前言：
从url输入到地址栏，到页面显示内容一般经历下面的步骤：
- DNS 解析:将域名解析成 IP 地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 断开连接：TCP 四次挥手
## 1、DNS解析：
一般我们输入的是URL，但是浏览器并不能通过URL直接来访问服务器。DNS解析就是一个将域名解析为对应的IP地址的过程。
### 1.1 浏览器通过域名转DNS的过程：
- 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。
- 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。
- 路由缓存：路由器也有 DNS 缓存。
- ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service - Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
- 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）
## 2、TCP链接（三次握手）：
TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率！

TCP连接的一方A，由操作系统动态`随机选取`一个32位长的序列号（Initial Sequence Number），假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。

同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。
### 2.1为什么是3次握手？
<!--more-->
**假设为四次握手**：

1.1 A 发送同步信号SYN + A's Initial sequence number

1.2 B 确认收到A的同步信号，并记录 A's ISN 到本地，命名 B's ACK sequence number

1.3 B发送同步信号SYN + B's Initial sequence number 

1.4 A确认收到B的同步信号，并记录 B's ISN 到本地，命名 A's ACK sequence number

很显然1.2和1.3 这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。


**二次握手怎么样？**：

2.1 A 发送同步信号SYN + A's Initial sequence number

2.2 B发送同步信号SYN + B's Initial sequence number + B's ACK sequence number

`这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。如果A发给B的确认丢了,
A不会超时重传这个ACK，因为TCP不会为`没有数据的ACK`(请求数据端)超时重传。B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。`

**丢包的情况**

1.A发给B的SYN 中途被丢，没有到达B

A会周期性超时重传，直到收到B的确认

2.B发给A的SYN +ACK 中途被丢，没有到达A

B会周期性超时重传，直到收到A的确认

3.第三个包，即A发给B的ACK 中途被丢，没有到达B

A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：


a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。

b. 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的 Data。

c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。

**’关于为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误‘**
> client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。

参考链接2：https://www.zhihu.com/question/24853633/answer/573627478
![三次握手](http://www.w3.org/2000/svg)

## 3.浏览器解析渲染页面
- 根据HTML解析出DOM树
- 根据CSS生成CSS规则树
- 根据DOM树和CSS规则树生成渲染树
- 根据渲染树计算每一个节点的信息
- 根据计算好的信息渲染页面

1. 根据 HTML 解析 DOM 树

    根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。
    在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。

2. 根据 CSS 解析生成 CSS 规则树

    解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。

    浏览器在 CSS 规则树生成之前不会进行渲染。

3. 结合 DOM 树和 CSS 规则树，生成渲染树

    DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。

    精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。

4. 根据渲染树计算每一个节点的信息（布局）

    布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸

    回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。

5. 根据计算好的信息绘制页面

    绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。

    重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。

    回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。

    ## 4.断开连接（TCP四次挥手）

  - 发送终止信号FIN和当前序列号
  - 被动方收到终止信号和主动方序列号，发送确认信号ack和自己的序列号seq给主动方。
  - 等待数据传送完毕，被动方发送终止信号FIN、确认信号ack和自己的序列号seq给主动方
  - 主动方收到终止信号FIN、确认信号ack和被动方序列号后，发送确认信号ack和序列号seq给被动方。

  >主动方发出确认信号2 MSL(报文最大生存时间)后关闭的主要原因是确保确认信号被被动方接受，如果报文丢包就超时重传，这样避免主动方关闭后，被动方无法正常关闭。
  
  三次握手的原因是接收方将确认信号ack、同步信号SYN和初始序列号使用同一个报文传送给发送方。而四次挥手是因为当被动方发送确认终止信号后，还可以继续传输数据给主动方，等数据发送完后才可以发送终止信号FIN


